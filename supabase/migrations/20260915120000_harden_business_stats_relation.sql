-- Hardening business_stats relation to prevent PostgREST 404 (PGRST205)
-- Ensures the relation exists in public schema with expected columns, policies, and seed data

-- 1) Create the table in public schema if it is missing
create table if not exists public.business_stats (
  id bigint generated by default as identity primary key,
  stat_type text not null,
  stat_value numeric not null default 0,
  label text,
  description text,
  is_active boolean not null default true,
  order_index integer not null default 0,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- 2) Backfill missing columns and guard required defaults/nullability
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'business_stats' AND column_name = 'label'
  ) THEN
    ALTER TABLE public.business_stats ADD COLUMN label text;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'business_stats' AND column_name = 'description'
  ) THEN
    ALTER TABLE public.business_stats ADD COLUMN description text;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'business_stats' AND column_name = 'stat_value'
  ) THEN
    ALTER TABLE public.business_stats ADD COLUMN stat_value numeric not null default 0;
  ELSE
    ALTER TABLE public.business_stats ALTER COLUMN stat_value SET DEFAULT 0;
    UPDATE public.business_stats SET stat_value = 0 WHERE stat_value IS NULL;
    ALTER TABLE public.business_stats ALTER COLUMN stat_value SET NOT NULL;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'business_stats' AND column_name = 'stat_type'
  ) THEN
    ALTER TABLE public.business_stats ADD COLUMN stat_type text;
  END IF;

  IF EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'business_stats' AND column_name = 'stat_type'
  ) THEN
    UPDATE public.business_stats SET stat_type = 'unspecified_stat' WHERE stat_type IS NULL;
    ALTER TABLE public.business_stats ALTER COLUMN stat_type SET NOT NULL;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'business_stats' AND column_name = 'is_active'
  ) THEN
    ALTER TABLE public.business_stats ADD COLUMN is_active boolean not null default true;
  ELSE
    ALTER TABLE public.business_stats ALTER COLUMN is_active SET DEFAULT true;
    UPDATE public.business_stats SET is_active = true WHERE is_active IS NULL;
    ALTER TABLE public.business_stats ALTER COLUMN is_active SET NOT NULL;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'business_stats' AND column_name = 'order_index'
  ) THEN
    ALTER TABLE public.business_stats ADD COLUMN order_index integer not null default 0;
  ELSE
    ALTER TABLE public.business_stats ALTER COLUMN order_index SET DEFAULT 0;
    UPDATE public.business_stats SET order_index = 0 WHERE order_index IS NULL;
    ALTER TABLE public.business_stats ALTER COLUMN order_index SET NOT NULL;
  END IF;
END $$;

-- 3) Ensure uniqueness on stat_type for deterministic upserts
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'business_stats_stat_type_key'
      AND conrelid = 'public.business_stats'::regclass
  ) THEN
    ALTER TABLE public.business_stats ADD CONSTRAINT business_stats_stat_type_key UNIQUE (stat_type);
  END IF;
END $$;

-- 4) Updated_at trigger for consistent timestamps
create or replace function public.set_business_stats_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists business_stats_set_updated_at on public.business_stats;
create trigger business_stats_set_updated_at
before update on public.business_stats
for each row
execute procedure public.set_business_stats_updated_at();

-- 5) RLS and anon read policy for public metrics
alter table public.business_stats enable row level security;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename = 'business_stats'
      AND policyname = 'Allow anon read active business stats'
  ) THEN
    CREATE POLICY "Allow anon read active business stats" ON public.business_stats
      FOR SELECT USING (is_active = true);
  END IF;
END $$;

-- 6) Seed default metrics to avoid empty responses
insert into public.business_stats (stat_type, stat_value, label, description, is_active, order_index)
values
  ('businesses', 0, 'SMEs Supported', 'Small and medium enterprises empowered through the platform', true, 1),
  ('professionals', 0, 'Business Professionals', 'Operators and SME leads onboarded', true, 2),
  ('freelancers', 0, 'Independent Freelancers', 'Service providers available for projects', true, 3),
  ('investors', 0, 'Active Investors', 'Funding partners engaged with the ecosystem', true, 4),
  ('donors', 0, 'Donors & Supporters', 'Community and philanthropic supporters', true, 5),
  ('funding', 0, 'Total Funding Raised', 'Capital mobilized for SME growth (USD)', true, 6),
  ('transactions', 0, 'Projects Completed', 'Successful business initiatives delivered', true, 7),
  ('jobs_created', 0, 'Jobs Created', 'Employment opportunities generated', true, 8),
  ('countries_served', 0, 'Countries Served', 'Regional impact reach', true, 9),
  ('success_stories', 0, 'Success Stories', 'Projects with verified outcomes', true, 10)
on conflict (stat_type) do update
  set label = excluded.label,
      description = excluded.description,
      is_active = excluded.is_active,
      order_index = excluded.order_index,
      stat_value = public.business_stats.stat_value;
