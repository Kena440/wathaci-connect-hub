# Signup audit correlation and recovery playbook

This guide aligns Supabase auth audit logs with application tables so that signups, profiles, and telemetry stay consistent. It also documents SQL you can run directly in the project database.

## 1. Normalize audit entries (actor-based)

Use the view from `supabase/migrations/20251127120000_signup_audit_correlation.sql`:

```sql
SELECT *
FROM public.audit_signup_normalized
ORDER BY audit_created_at DESC
LIMIT 50;
```

Columns:
- `actor_id`: UUID string that matches `auth.users.id` when Supabase actually creates the user.
- `actor_email_clean`: `actor_username` with the `" [blocked]"` suffix stripped so you can join on email.
- `actor_username_raw`: raw value from the audit entry (often shows the `[blocked]` suffix).
- `provider`, `action`, `log_type`, `audit_created_at`: direct audit metadata.

`[blocked]` entries are generated by Supabase abuse protection/rate limiting during signup flows. They normally **do not create an `auth.users` row**, so joins should treat them as audit-only signals.

## 2. Correlate audit → auth.users → public.profiles

```sql
SELECT *
FROM public.audit_signup_correlations
ORDER BY audit_created_at DESC
LIMIT 200;
```

Join logic:
- First match `actor_id` to `auth.users.id` (string compare), then fall back to `actor_email_clean` to handle older payloads.
- Profiles join primarily on `profiles.id = auth.users.id` with a fallback on matching email.

Health rollup:

```sql
SELECT * FROM public.audit_signup_health_summary;
```

Interpretation:
- `has_auth = true`, `has_profile = true` → healthy signup.
- `has_auth = true`, `has_profile = false` → profile missing; run the backfill and check triggers/RLS.
- `has_auth = false`, `has_profile = false` → audit-only/blocked; no user was created.
- `has_auth = false`, `has_profile = true` → inconsistent; usually a manually inserted profile.

## 3. Direct user ↔ profile integrity (independent of audit)

Check recent users missing profiles:

```sql
SELECT u.id, u.email, u.created_at
FROM auth.users u
LEFT JOIN public.profiles p ON p.id = u.id
WHERE p.id IS NULL
ORDER BY u.created_at DESC
LIMIT 200;
```

Backfill any gaps safely:

```sql
INSERT INTO public.profiles (id, email, created_at)
SELECT u.id, u.email, timezone('utc', now())
FROM auth.users u
LEFT JOIN public.profiles p ON p.id = u.id
WHERE p.id IS NULL;
```

The `public.handle_new_user` trigger (refreshed in the latest migrations) already calls `public.ensure_profile_exists` and logs `signup_completed` into `public.user_events`.

## 4. Handle `[blocked]` audit entries

Isolate blocked attempts:

```sql
SELECT *
FROM public.audit_blocked_signups
ORDER BY audit_created_at DESC
LIMIT 100;
```

Guidance:
- Treat these as rate-limited/abuse-filtered attempts. Do **not** assume a real user exists.
- Surface a friendly UI message like “Too many signup attempts, please try again later.”
- Optionally log them into `public.user_events` with `event_type = 'signup_blocked'` and `metadata.reason = 'abuse_protection'`.

## 5. Strengthened application logging (public.user_events)

`public.user_events` now carries `event_type`, `email`, and `metadata` alongside legacy fields. Use the helper:

```sql
SELECT public.log_user_event(
  p_user_id => '00000000-0000-0000-0000-000000000000',
  p_event_type => 'signup_completed',
  p_email => 'user@example.com',
  p_metadata => jsonb_build_object('provider', 'email', 'source', 'web')
);
```

Recommended event types: `signup_started`, `signup_completed`, `profile_created`, `login_success`, `login_failed`, `signup_blocked`.

## 6. Monitoring snippets

Recent users missing profiles (last 10 minutes):

```sql
SELECT u.id, u.email, u.created_at
FROM auth.users u
LEFT JOIN public.profiles p ON p.id = u.id
WHERE p.id IS NULL
  AND u.created_at > now() - interval '10 minutes';
```

Profiles with no `signup_completed` event:

```sql
SELECT u.id, u.email, u.created_at
FROM auth.users u
JOIN public.profiles p ON p.id = u.id
LEFT JOIN public.user_events e
  ON e.user_id = u.id AND e.event_type = 'signup_completed'
WHERE e.id IS NULL
  AND u.created_at > now() - interval '10 minutes';
```

Blocked attempts by email:

```sql
SELECT actor_email_clean AS email,
       COUNT(*) AS blocked_attempts,
       MIN(audit_created_at) AS first_attempt,
       MAX(audit_created_at) AS last_attempt
FROM public.audit_blocked_signups
GROUP BY actor_email_clean
ORDER BY blocked_attempts DESC
LIMIT 50;
```

Suggested thresholds: investigate any blocked count > 3 within 15 minutes, and alert when `has_auth = true, has_profile = false` appears in `public.audit_signup_health_summary`.

## 7. Why traits.user_id/user_email were empty

The signup-related audit payloads only populate `actor_id` and `actor_username`. The `traits` object for these actions carries only the provider. Use the normalized views above to join through `actor_id` (preferred) and `actor_email_clean` (fallback).

Once `public.user_events` is emitted during signup, you can rely on application-owned telemetry instead of the internal audit payload shapes.
